# Example AI Agent Responses

This document shows examples of how the AI agent responds to different types of GitHub issues.

## Example 1: Database Connection Issue

**Issue Title:** "Cannot connect to PostgreSQL database"

**Issue Body:**
```
I'm getting this error when trying to connect:

Error: connect ETIMEDOUT
at Connection._handleConnectTimeout

Using the pg library in Node.js.
```

**AI Response:**

---

Hi @username! ðŸ‘‹

I'm an AI assistant here to help troubleshoot your issue. Here's my analysis:

## Problem Analysis

You're experiencing a connection timeout (`ETIMEDOUT`) when trying to connect to PostgreSQL using the `pg` library in Node.js. This typically indicates that your application cannot reach the database server within the allocated timeout period.

## Suggested Solutions

### 1. Verify Database Connection Parameters

Ensure your connection string or configuration object has the correct format:

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: 'your-db-host.com',
  port: 5432,
  database: 'your_database',
  user: 'your_user',
  password: 'your_password',
  connectionTimeoutMillis: 5000, // Increase if needed
  ssl: {
    rejectUnauthorized: false // For self-signed certificates
  }
});
```

**Action items:**
- Double-check the `host` and `port` values
- Ensure the database is running and accessible
- Test connectivity using `psql` CLI: `psql -h your-db-host.com -U your_user -d your_database`

### 2. Check Network Configuration and Firewall Rules

The timeout suggests a network connectivity issue:

```bash
# Test if you can reach the database host
ping your-db-host.com

# Test if the PostgreSQL port is open
telnet your-db-host.com 5432
# OR
nc -zv your-db-host.com 5432
```

**Common causes:**
- Database server firewall blocking your IP address
- Cloud provider security groups not allowing inbound connections
- VPN or proxy configuration issues
- Incorrect DNS resolution

**Solutions:**
- Add your application's IP to the database allowlist
- Check cloud provider (AWS, GCP, Azure) security group rules
- Verify VPC/subnet configuration if using cloud services

### 3. Increase Connection Timeout and Add Retry Logic

If the database is slow to respond, increase the timeout and implement retry logic:

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: 'your-db-host.com',
  port: 5432,
  database: 'your_database',
  user: 'your_user',
  password: 'your_password',
  connectionTimeoutMillis: 10000, // Increased to 10 seconds
  idleTimeoutMillis: 30000,
});

// Retry logic
async function connectWithRetry(maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const client = await pool.connect();
      console.log('Connected to database');
      return client;
    } catch (err) {
      console.log(`Connection attempt ${i + 1} failed:`, err.message);
      if (i === maxRetries - 1) throw err;
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s
    }
  }
}
```

## Additional Debugging Steps

Enable debug logging to see detailed connection attempts:

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  // ... your config
});

pool.on('connect', () => {
  console.log('New client connected to pool');
});

pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
});
```

## References

- [node-postgres Connection Documentation](https://node-postgres.com/features/connecting)
- [PostgreSQL Connection Troubleshooting Guide](https://www.postgresql.org/docs/current/server-start.html)
- [Debugging Network Connectivity Issues](https://node-postgres.com/guides/async-express)

---

*This response was generated by an AI assistant. While I strive to provide helpful suggestions, please verify solutions in your specific context. If you need further assistance, feel free to ask follow-up questions or tag a human maintainer.*

---

## Example 2: React Error

**Issue Title:** "Getting 'Cannot read property of undefined' in React component"

**Issue Body:**
```
My app crashes with this error:

TypeError: Cannot read property 'map' of undefined
at UserList.render

Here's my component:

function UserList() {
  const [users, setUsers] = useState();
  
  return (
    <div>
      {users.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}
```

**AI Response:**

---

Hi @username! ðŸ‘‹

I'm an AI assistant here to help troubleshoot your issue. Here's my analysis:

## Problem Analysis

Your React component is attempting to call `.map()` on `users` before it's been initialized. The `useState()` hook is being called without an initial value, which means `users` is `undefined` when the component first renders. You cannot call `.map()` on `undefined`.

## Suggested Solutions

### 1. Initialize useState with an Empty Array

The simplest fix is to provide an initial value to `useState`:

```javascript
import { useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]); // Initialize with empty array
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

**Why this works:**
- `users` is now an empty array `[]` instead of `undefined`
- `.map()` on an empty array returns an empty array (no error)
- When you fetch data and call `setUsers([...data])`, the component re-renders with the new data

### 2. Add Conditional Rendering (Defensive Approach)

If `users` might legitimately be `null` or `undefined` during loading, add a safety check:

```javascript
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUsers() {
      try {
        const response = await fetch('/api/users');
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error('Failed to fetch users:', error);
        setUsers([]); // Set empty array on error
      } finally {
        setLoading(false);
      }
    }
    
    fetchUsers();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (!users || users.length === 0) return <div>No users found</div>;

  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

### 3. Use Optional Chaining (Quick Fix)

For a quick inline fix, use optional chaining with a fallback:

```javascript
function UserList() {
  const [users, setUsers] = useState();
  
  return (
    <div>
      {users?.map(user => (
        <div key={user.id}>{user.name}</div>
      )) || <div>No users to display</div>}
    </div>
  );
}
```

## Best Practice Recommendation

**Solution #2** is the most robust approach because it:
- âœ… Handles loading states properly
- âœ… Shows user feedback during data fetching
- âœ… Gracefully handles errors
- âœ… Provides empty state messaging

## References

- [React useState Hook Documentation](https://react.dev/reference/react/useState)
- [React Conditional Rendering Guide](https://react.dev/learn/conditional-rendering)
- [JavaScript Optional Chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)

---

*This response was generated by an AI assistant. While I strive to provide helpful suggestions, please verify solutions in your specific context. If you need further assistance, feel free to ask follow-up questions or tag a human maintainer.*

---

## Example 3: TypeScript Type Error

**Issue Title:** "TypeScript error: Property 'userId' does not exist on type 'Request'"

**Issue Body:**
```
Getting this error in my Express middleware:

Property 'userId' does not exist on type 'Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>'

Code:
req.userId = decoded.userId;
```

**AI Response:**

---

Hi @username! ðŸ‘‹

I'm an AI assistant here to help troubleshoot your issue. Here's my analysis:

## Problem Analysis

TypeScript doesn't recognize custom properties added to Express's `Request` object. By default, the `Request` type from `@types/express` doesn't include a `userId` property, so TypeScript raises a type error when you try to assign to `req.userId`.

## Suggested Solutions

### 1. Extend Express Request Type (Recommended)

Create a type declaration file to extend the Express `Request` interface:

**Create `src/types/express.d.ts`:**

```typescript
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      userId?: string; // Add your custom properties here
      user?: {
        id: string;
        email: string;
        role: string;
      };
    }
  }
}
```

**Ensure TypeScript includes this file:**

In your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src/**/*"]
}
```

Now you can use `req.userId` without errors:

```typescript
import { Request, Response, NextFunction } from 'express';

function authMiddleware(req: Request, res: Response, next: NextFunction) {
  const decoded = verifyToken(req.headers.authorization);
  req.userId = decoded.userId; // âœ… No error
  next();
}
```

### 2. Use Type Assertion (Quick Fix)

If you need a quick fix without modifying types:

```typescript
(req as any).userId = decoded.userId;
```

**Caution:** This bypasses type checking and should only be used temporarily. Solution #1 is preferred for production code.

### 3. Create a Custom Request Interface

Alternatively, create your own request type:

```typescript
import { Request } from 'express';

interface AuthenticatedRequest extends Request {
  userId: string;
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const decoded = verifyToken(req.headers.authorization);
  (req as AuthenticatedRequest).userId = decoded.userId;
  next();
}

// In your routes
app.get('/profile', (req: AuthenticatedRequest, res) => {
  const userId = req.userId; // âœ… Type-safe
  // ...
});
```

## Complete Example

**`src/types/express.d.ts`:**
```typescript
declare global {
  namespace Express {
    interface Request {
      userId?: string;
    }
  }
}

export {};
```

**`src/middleware/auth.ts`:**
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as {
      userId: string;
    };
    
    req.userId = decoded.userId; // âœ… Type-safe now
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
}
```

## References

- [TypeScript Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)
- [Express TypeScript Guide](https://expressjs.com/en/advanced/best-practice-performance.html)
- [DefinitelyTyped Express Types](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/express)

---

*This response was generated by an AI assistant. While I strive to provide helpful suggestions, please verify solutions in your specific context. If you need further assistance, feel free to ask follow-up questions or tag a human maintainer.*

---